use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"));
    let sqllogic_dir = manifest_dir.join("tests").join("sqllogic");

    let mut slt_files = Vec::new();
    collect_slt_files(&sqllogic_dir, &mut slt_files);
    slt_files.sort();

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let out_file = out_dir.join("sqllogic_tests.rs");

    let mut generated = String::new();
    generated.push_str("// @generated by build.rs; do not edit\n");
    for path in slt_files {
        let test_name = make_test_name(&sqllogic_dir, &path);
        let path_str = path
            .to_str()
            .expect("Non-UTF8 path in sqllogic tests; unsupported for generation");
        generated.push_str(&format!(
            "#[tokio::test(flavor = \"multi_thread\")]\n\
             async fn {}() -> Result<(), Box<dyn std::error::Error>> {{\n\
                 run_single_slt_file(std::path::Path::new(\"{}\"))\n\
                    .await\n\
             }}\n\n",
            test_name, path_str
        ));
    }

    fs::write(&out_file, generated).expect("Failed to write generated sqllogic tests");

    println!("cargo:rerun-if-changed=tests/sqllogic");
}

fn collect_slt_files(dir: &Path, files: &mut Vec<PathBuf>) {
    if !dir.exists() {
        return;
    }

    let entries = match fs::read_dir(dir) {
        Ok(entries) => entries,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_slt_files(&path, files);
        } else if path
            .extension()
            .map(|ext| ext.eq_ignore_ascii_case("slt"))
            .unwrap_or(false)
        {
            files.push(path);
        }
    }
}

fn make_test_name(root: &Path, path: &Path) -> String {
    let relative = path
        .strip_prefix(root)
        .unwrap_or(path)
        .to_string_lossy()
        .to_string();
    let trimmed = relative.trim_end_matches(".slt");
    let mut name = String::from("slt_");
    name.push_str(
        &trimmed
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() {
                    c.to_ascii_lowercase()
                } else {
                    '_'
                }
            })
            .collect::<String>(),
    );
    name
}

