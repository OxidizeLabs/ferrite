---
description: Network protocols, client-server communication guidelines
globs: ["src/network/**/*.rs", "src/server/**/*.rs", "src/client/**/*.rs"]
alwaysApply: false
---

# Networking and Client-Server Guidelines

When working with networking components, focus on protocol correctness, connection management, and performance.

## Network Protocol Design

### Packet Structure
- Design clear, versioned packet formats
- Use proper serialization for network messages
- Handle endianness for cross-platform compatibility
- Implement packet validation and checksums
- Support protocol negotiation between versions

### Message Types
```rust
// Proper packet design pattern
#[derive(Debug, Serialize, Deserialize)]
pub enum DatabasePacket {
    Connect { version: u32, database: String },
    Query { sql: String, params: Vec<Value> },
    Response { status: ResponseStatus, data: Vec<Tuple> },
    Error { code: ErrorCode, message: String },
}
```

## Server Implementation

### Connection Management
- Handle multiple concurrent client connections
- Implement proper connection lifecycle management
- Use connection pooling for resource efficiency
- Handle connection timeouts and cleanup
- Implement graceful shutdown procedures

### Async Server Pattern
- Use `tokio` for async networking
- Handle client connections in separate tasks
- Implement proper error handling for network errors
- Use efficient event loop for I/O multiplexing

```rust
// Proper async server pattern
async fn handle_client(stream: TcpStream) -> Result<()> {
    let mut connection = Connection::new(stream);
    loop {
        match connection.read_packet().await? {
            Some(packet) => {
                let response = process_packet(packet).await?;
                connection.write_packet(response).await?;
            }
            None => break, // Client disconnected
        }
    }
    Ok(())
}
```

### Request Processing
- Parse client requests correctly
- Validate request parameters
- Integrate with SQL execution engine
- Handle query results efficiently
- Implement proper error responses

## Client Implementation

### Connection Pool Management
- Implement client connection pooling
- Handle connection health checks
- Implement connection retry logic
- Manage connection lifecycle efficiently
- Handle connection failures gracefully

### Request/Response Handling
- Implement proper request serialization
- Handle response deserialization
- Manage request timeouts
- Implement request retries for transient failures
- Handle partial responses correctly

### Async Client Pattern
```rust
// Proper async client pattern
impl DatabaseClient {
    pub async fn execute_query(&self, sql: &str) -> Result<QueryResult> {
        let mut conn = self.pool.get_connection().await?;
        let packet = QueryPacket::new(sql);
        conn.send_packet(packet).await?;
        let response = conn.read_response().await?;
        Ok(response.into_result()?)
    }
}
```

## Protocol Features

### Authentication
- Implement secure authentication mechanisms
- Support multiple authentication methods
- Handle authentication state properly
- Implement session management
- Use secure password handling

### Compression
- Support optional message compression
- Choose appropriate compression algorithms
- Handle compression negotiation
- Balance compression ratio vs. CPU usage

### Streaming Results
- Support streaming large result sets
- Implement proper backpressure handling
- Handle partial result transmission
- Support result set paging
- Implement cursor-based pagination

## Error Handling

### Network Error Management
- Handle connection drops gracefully
- Implement proper error propagation
- Distinguish network vs. application errors
- Log network errors with appropriate detail
- Handle timeout scenarios properly

### Protocol Error Handling
- Validate protocol conformance
- Handle malformed packets
- Implement proper error codes
- Provide meaningful error messages
- Handle protocol version mismatches

## Performance Considerations

### Throughput Optimization
- Use efficient serialization formats
- Minimize network round trips
- Batch operations when possible
- Implement connection keep-alive
- Use appropriate buffer sizes

### Latency Optimization
- Minimize serialization overhead
- Use TCP_NODELAY for low latency
- Implement proper connection reuse
- Avoid unnecessary memory allocations
- Profile network bottlenecks

### Resource Management
- Limit concurrent connections appropriately
- Implement proper memory management
- Handle resource cleanup on errors
- Monitor network resource usage
- Implement circuit breaker patterns for reliability