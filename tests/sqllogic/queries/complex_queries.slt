# Complex Query Tests

# Setup test tables and data
statement ok
CREATE TABLE departments (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    budget DECIMAL(10,2)
);

statement ok
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    department_id INTEGER,
    salary DECIMAL(10,2),
    hire_date DATE,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);

statement ok
CREATE TABLE projects (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    department_id INTEGER,
    start_date DATE,
    end_date DATE,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);

statement ok
CREATE TABLE employee_projects (
    employee_id INTEGER,
    project_id INTEGER,
    role TEXT,
    PRIMARY KEY (employee_id, project_id),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (project_id) REFERENCES projects(id)
);

# Insert test data
statement ok
INSERT INTO departments (id, name, budget) VALUES
    (1, 'Engineering', 1000000.00),
    (2, 'Marketing', 500000.00),
    (3, 'Sales', 750000.00);

statement ok
INSERT INTO employees (id, name, department_id, salary, hire_date) VALUES
    (1, 'Alice', 1, 80000.00, '2020-01-15'),
    (2, 'Bob', 1, 85000.00, '2020-02-01'),
    (3, 'Charlie', 2, 70000.00, '2020-03-15'),
    (4, 'David', 2, 75000.00, '2021-01-01'),
    (5, 'Eve', 3, 90000.00, '2019-12-01');

statement ok
INSERT INTO projects (id, name, department_id, start_date, end_date) VALUES
    (1, 'Project A', 1, '2020-01-01', '2020-12-31'),
    (2, 'Project B', 1, '2020-06-01', '2021-05-31'),
    (3, 'Project C', 2, '2020-03-01', '2021-02-28');

statement ok
INSERT INTO employee_projects (employee_id, project_id, role) VALUES
    (1, 1, 'Lead'),
    (1, 2, 'Developer'),
    (2, 1, 'Developer'),
    (2, 2, 'Lead'),
    (3, 3, 'Lead'),
    (4, 3, 'Developer');

# Test complex joins
query TTRI
SELECT
    e.name as employee,
    d.name as department,
    e.salary,
    COUNT(ep.project_id) as project_count
FROM employees e
JOIN departments d ON e.department_id = d.id
LEFT JOIN employee_projects ep ON e.id = ep.employee_id
GROUP BY e.id, e.name, d.name, e.salary
ORDER BY e.name;
----
Alice Engineering 80000.00 2
Bob Engineering 85000.00 2
Charlie Marketing 70000.00 1
David Marketing 75000.00 1
Eve Sales 90000.00 0

# Test subquery in WHERE clause
query TT
SELECT e.name, d.name as department
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary > (
    SELECT AVG(salary)
    FROM employees
)
ORDER BY e.salary DESC;
----
Eve Sales
Bob Engineering

# Test window functions
query TTR
SELECT
    e.name,
    d.name as department,
    e.salary,
    RANK() OVER (PARTITION BY d.id ORDER BY e.salary DESC) as dept_rank
FROM employees e
JOIN departments d ON e.department_id = d.id
ORDER BY d.name, dept_rank;
----
Bob Engineering 85000.00 1
Alice Engineering 80000.00 2
David Marketing 75000.00 1
Charlie Marketing 70000.00 2
Eve Sales 90000.00 1

# Test complex aggregates
query TRR
SELECT
    d.name,
    AVG(e.salary) as avg_salary,
    d.budget / COUNT(e.id) as budget_per_employee
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name, d.budget
HAVING COUNT(e.id) > 0
ORDER BY avg_salary DESC;
----
Sales 90000.00 750000.00
Engineering 82500.00 500000.00
Marketing 72500.00 250000.00

# Test date functions and conditions
query TT
SELECT e.name, p.name as project
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN projects p ON ep.project_id = p.id
WHERE e.hire_date <= p.start_date
AND ep.role = 'Lead'
ORDER BY e.hire_date;
----
Bob Project B

# Test UNION and set operations
query T
SELECT name FROM employees
WHERE department_id = 1
UNION
SELECT name FROM employees
WHERE salary > 80000
ORDER BY name;
----
Alice
Bob
Eve
